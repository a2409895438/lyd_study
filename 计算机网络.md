# 计算机网络

### 1. OSI的七层模型分别是什么？各自的功能是什么？

#### 简要概括

- 物理层：负责在物理网络中传输数据帧
- 数据链路层：负责数据的封帧以及差错检测，以及MAC寻址
- 网络层：负责数据的路由、转发和分片
- 传输层：端到端传输数据的基本功能
- 会话层：控制应用程序之间的会话能力，如不同软件数据分发给不同的软件
- 表示层：数据格式表示
- 应用层：各种应用软件，包括Web应用

### 2. 三次握手

1. 第一次握手：客户端给服务器发送一个SYN报文
2. 第二次握手：服务端受到SYN报文后，应答一个SYN和ACK报文
3. 第三次握手：客户端受到SYN和ACK报文后，会回应一个ACK报文
4. 服务器受到ACK报文后，三次握手建立完成



​	第一次握手：服务端得到结论：客户端的发送能力和服务端的接受能力是正常的

​	第二次握手：客户端得到结论：服务端的接受和发送能力是正常的，客户端的发送和接受能力是正常的

​	第三次握手： 服务端得到结论： 服务端的接受和发送能力是正常的，客户端的发送和接受能力是正常的

> ​	为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤
>
> ​	如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认



### 3. 四次挥手

假如是客户端先发起关闭请求:

1. 第一次挥手：客户端发送一个FIN报文，报文中会指定一个序列号，此时客户端处于FIN_WAIT1状态
2. 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列值，表明已经收到客户端的报文了，此时服务端处于 **CLOSE_WAIT**状态。
3. 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号此时服务端处于 **LAST_ACK** 的状态。
4. 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 **TIME_WAIT** 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态
5. 服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。

### 4. TCP和UDP的区别

UDP和TCP协议都是传输层协议。

TCP（传输控制协议）提供的是面向连接，可靠的字节流服务，客户和服务器交换数据前，必须在双方之间建立一个TCP连接，然后才可以传输数据。并且提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传输到另一端。

UPD（用户数据报协议）是一个简单的面向数据报的运输层协议。它不提供可靠性，只是把应用程序传给IP层的数据报发送出去，但是不能保证它们能到达目的地。由于UDP在传输数据报之前不用客户和服务器之间建立一个连接，且没有超时重发等机制，所以传输速度很快。

区别如下

1. TCP面向连接；UDP是发送数据前不需要建立连接
2. TCP提供可靠的服务。也就是说，通过TCP连接传输的数据，无差错，不丢失，不重复，按序到达。UDP不保证可靠的交付。
3. TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流；UDP是面向报文，没有拥塞控制，因此网络中出现拥塞不会使源主机的发送效率降低（对实时应用很有用，如IP电话或者实时视频会议等）
4. 每一条TCP连接只能是点对点的；UDP支持一对一，一对多，多对一和多对多的交互通信
5. TCP首部开销20字节；UDP的首部开销小，只有8字节
6. TCP的逻辑通信信道是全双工的可靠信道，UDP是不可靠信道

### 5. POST和GET的区别

> 使用场景

GET用于 获取资源，而POST用于传输实体主体

> 参数

GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。

因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 `中文` 会转换为 `%E4%B8%AD%E6%96%87`，而空格会转换为 `%20`。POST 参数支持标准字符集。

> 安全性

安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。

GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。

安全的方法除了 GET 之外还有：HEAD、OPTIONS。

不安全的方法除了 POST 之外还有 PUT、DELETE。

> 幂等性

幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。

> 所有的安全方法也都是幂等的。

在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。

> 可缓存

如果要对响应进行缓存，需要满足以下条件：

- 请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。
- 响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。
- 响应报文的 Cache-Control 首部字段没有指定不进行缓存。

### 6. HTTP常见的状态码

> 状态码分类

- 1xx：表示目前是协议的中间状态，还需要后续请求
- 2xx：表示请求成功
- 3xx：表示重定向状态，需要重新请求
- 4xx：表示请求报文错误
- 5xx：服务器端错误

> 常用状态码

101 切换请求协议，从 HTTP 切换到 WebSocket

200 请求成功，有响应体

301 永久重定向：表示资源已被分配了新的 URL

302 临时重定向：表示资源临时被分配了新的 URL

303 表示资源存在另一个URL，用GET方法获取资源

304 协商缓存命中

403 服务器禁止访问

404 资源未找到

400 请求错误

500 服务器端错误

503 服务器繁忙

### 7. TCP拥塞控制原理

原因可能是整个网络环境特别差，容易丢包。主要有三种方法：

1. 慢启动阈值 + 拥塞避免

------

对于拥塞控制来说，TCP主要维护两个核心状态：

- 拥塞窗口（cwnd）
- 慢启动阈值(ssthresh)

在发送端用拥塞窗口来控制发送窗口的大小

然后采用一种比较保守的慢启动算法来慢慢适应这个网络，在开始传输的一段时间，发送端和接收端会首先通过三次握手建立连接，确定各自接收窗口大小，然后初始化双方的拥塞窗口，接着每经过一轮 RTT（收发时延），拥塞窗口大小翻倍，直到达到慢启动阈值。

然后开始进行拥塞避免，拥塞避免具体的做法就是之前每一轮 RTT，拥塞窗口翻倍，现在每一轮就加一个。

---



2. 快速重传

---

在 TCP 传输过程中，如果发生了丢包，接收端就会发送之前重复 ACK，比如 第 5 个包丢了，6、7 达到，然后接收端会为 5，6，7 都发送第四个包的 ACK，这个时候发送端收到了 3 个重复的 ACK，意识到丢包了，就会马上进行重传，而不用等到 RTO （超时重传的时间）

选择性重传：报文首部可选性中加入 SACK 属性，通过 left edge 和 right edge 标志那些包到了，然后重传没到的包

---

3. 快速恢复

---

如果发送端收到了 3 个重复的 ACK，发现了丢包，觉得现在的网络状况已经进入拥塞状态了，那么就会进入快速恢复阶段：

- 会将拥塞阈值降低为 拥塞窗口的一半
- 然后拥塞窗口大小变为拥塞阈值
- 接着 拥塞窗口再进行线性增加，以适应网络状况



### 8. 什么是SQL 注入？举个例子？

SQL注入就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。

1). SQL注入攻击的总体思路

​	(1). 寻找到SQL注入的位置

​	(2). 判断服务器类型和后台数据库类型

​	(3). 针对不同的服务器和数据库特点进行SQL注入攻击

2). SQL注入攻击实例

比如，在一个登录界面，要求输入用户名和密码，可以这样输入实现免帐号登录：

```shell
用户名： ‘or 1 = 1 --
密 码：
```

用户一旦点击登录，如若没有做特殊处理，那么这个非法用户就很得意的登陆进去了。这是为什么呢?

下面我们分析一下：从理论上说，后台认证程序中会有如下的SQL语句：

```java
String sql = “select * from user_table where username=’ “+userName+” ’ and password=’ “+password+” ‘”;
```

因此，当输入了上面的用户名和密码，上面的SQL语句变成：

```java
SELECT * FROM user_table WHERE username=’’or 1 = 1 –- and password=’’
```

分析上述SQL语句我们知道，username=‘ or 1=1 这个语句一定会成功；然后后面加两个 -，这意味着注释，它将后面的语句注释，让他们不起作用。这样，上述语句永远都能正确执行，用户轻易骗过系统，获取合法身份。

3). 应对方法

(1). 参数绑定

使用预编译手段，绑定参数是最好的防SQL注入的方法。目前许多的ORM框架及JDBC等都实现了SQL预编译和参数绑定功能，攻击者的恶意SQL会被当做SQL的参数而不是SQL命令被执行。在mybatis的mapper文件中，对于传递的参数我们一般是使用 # 和`$`来获取参数值。

当使用#时，变量是占位符，就是一般我们使用javajdbc的PrepareStatement时的占位符，所有可以防止sql注入；当使用`$`时，变量就是直接追加在sql中，一般会有sql注入问题。

(2). 使用正则表达式过滤传入的参数

### 9. XSS攻击





### 10. 网络五层模型

下面是网络通信的五层模型：

![image-20210920130513026](https://shuaidi-picture-1257337429.cos.ap-guangzhou.myqcloud.com/img/image-20210920130513026.png)

- 物理层

  物理层负责把两台计算机连起来，然后在计算机之间通过高低电频来传送0,1这样的电信号。

- 数据链路层

- 网络层
- 传输层
- 应用层
